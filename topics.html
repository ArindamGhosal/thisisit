<!DOCTYPE html>
<html>
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Cryptography Topics</title>
    <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/bootstrap@4.6.2/dist/css/bootstrap.min.css">
    <script src="https://cdn.jsdelivr.net/npm/jquery@3.6.4/dist/jquery.slim.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/popper.js@1.16.1/dist/umd/popper.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/bootstrap@4.6.2/dist/js/bootstrap.bundle.min.js"></script>
    <link href="https://cdn.jsdelivr.net/npm/bootstrap@5.3.0/dist/css/bootstrap.min.css" rel="stylesheet" integrity="sha384-9ndCyUaIbzAi2FUVXJi0CjmCapSmO7SnpJef0486qhLnuZ2cdeRhO02iuK6FUUVM" crossorigin="anonymous">
<style>
 div.sticky {
  /* position: -webkit-sticky;
  position: sticky; */
  top: 0;
  padding: 5px;
  /* background-color: #cae8ca; */
  /* border: 2px solid #4CAF50; */
}


.center {
  display: flex;
  justify-content: center;
  align-items: center;
  height: 20x;
  /* border: 3px solid green;  */
}
.Notes{
    background-color: wheat;
}
.upper{
    background-color: orange;
}
 .upper{
            display: flex;
            justify-content: center;
            align-items:center;
        } 

body {
  background-image: url('c3.jpeg');
  background-repeat: no-repeat;
  background-attachment: fixed;
  background-size: 100% 100%;
}
</style>
</head>
<body>
<div class="upper">
    <h1>Cryptography</h1>
</div>


<div class="sticky"><div class="center">
    <nav class="navbar navbar-expand-md bg-dark navbar-dark">
      <a class="navbar-brand" href="#">Menu</a>
      <button class="navbar-toggler" type="button" data-toggle="collapse" data-target="#collapsibleNavbar">
        <span class="navbar-toggler-icon"></span>
      </button>
      
      <div class="collapse navbar-collapse" id="collapsibleNavbar">
        <ul class="navbar-nav">
          <li class="nav-item">
            <a class="nav-link" href="index.html">Home Page</a>
          </li>
          <li class="nav-item">
            <a class="nav-link" href="topics.html">Topics</a>
          </li>
          <li class="nav-item">
            <a class="nav-link" href="PC.html">P&C</a>
          </li>
          <!-- <li class="nav-item">
            <a class="nav-link" href="#">Contributors</a> -->
          <!-- <li class="nav-item">
              <a class="nav-link" href="resources.html">Resources</a>
            </li> -->
            <li class="nav-item">
              <a class="nav-link" href="#">Blogs</a>
            </li>
          </li>    
        </ul>
      </div>
      <a class="btn btn-primary" href="signup.html" role="button">Sign In/Sign Up</a>  
    </nav>
    <br>
    
  </div></div>

<div class="Notes" style="padding-bottom:2000px">
 <p>1: <a href="#ITC">Introduction to Cryptography </a>, Classical Cryptosystem, Block Cipher. </p>   
 
 <p>2: <a href="#DES">Data Encryption Standard (DES),Triple DES, Modes of Operation, Stream Cipher </a></p>  
    <p>3: LFSR based Stream Cipher, Mathematical background, Abstract algebra, Number Theory. </p> 
    <p>4: Modular Inverse, Extended Euclid Algorithm, Fermat's Little Theorem, Euler Phi-Function, Euler's theorem. </p> 
    <p>5: Advanced Encryption Standard (AES), Introduction to Public Key Cryptosystem, Diffie-Hellman Key Exchange, Knapsack Cryptosystem, RSA Cryptosystem. </p> 
    <p> 6: Primarily Testing, ElGamal Cryptosystem, Elliptic Curve over the Reals, Elliptic curve Modulo a Prime. </p> 
    <p>7: Generalized ElGamal Public Key Cryptosystem, Rabin Cryptosystem. </p>
    <p>8 : Message Authentication, Digital Signature, Key Management, Key Exchange, Hash Function. </p> 
    <p>9 : Cryptographic Hash Function, Secure Hash Algorithm (SHA), Digital Signature Standard (DSS). </p> 
    <p> 10: Cryptanalysis, Time-Memory Trade-off Attack, Differential and Linear Cryptanalysis. </p>
    <p>  11: Cryptanalysis on Stream Cipher, Modern Stream Ciphers, Shamir's secret sharing and BE, Identity-based Encryption (IBE), Attribute-based Encryption (ABE). </p>
    <p>12: Side-channel attack, The Secure Sockets Layer (SSL), Pretty Good Privacy (PGP), Introduction to Quantum Cryptography, Blockchain, Bitcoin and Cryptocurrency.  </p>

    <p><div id = "ITC"><u>Introduction to Cryptography:-</u>
      
        <p>Cryptography is the study and practice of techniques for secure communication in the presence of third parties called adversaries. <br>It deals with developing and analyzing protocols that prevents malicious third parties from retrieving information being shared between two entities thereby following the various aspects of information security. <br>Secure Communication refers to the scenario where the message or data shared between two parties can‚Äôt be accessed by an adversary.<br> In Cryptography, an Adversary is a malicious entity, which aims to retrieve precious information or data thereby undermining the principles of information security.<br> Data Confidentiality, Data Integrity, Authentication and Non-repudiation are core principles of modern-day cryptography.
            <br>

            Confidentiality refers to certain rules and guidelines usually executed under confidentiality agreements which ensure that the information is restricted to certain people or places.<br>
            Data integrity refers to maintaining and making sure that the data stays accurate and consistent over its entire life cycle.<br>
            Authentication is the process of making sure that the piece of data being claimed by the user belongs to it.<br>
            Non-repudiation refers to the ability to make sure that a person or a party associated with a contract or a communication cannot deny the authenticity of their signature over their document or the sending of a message.<br>
        
        Consider two parties Alice and Bob. <br>Now, Alice wants to send a message m to Bob over a secure channel. <br>So, what happens is as follows. <br>The sender‚Äôs message or sometimes called the Plaintext, is converted into an unreadable form using a Key k.<br> The resultant text obtained is called the Ciphertext.<br> This process is known as Encryption.<br> At the time of received, the Ciphertext is converted back into the plaintext using the same Key k, so that it can be read by the receiver.<br> This process is known as Decryption.
        
        Alice (Sender)       Bob (Receiver)
        C = E (m, k)  ---->    m = D (C, k) 
        
        Here, C refers to the Ciphertext while E and D are the Encryption and Decryption algorithms respectively.<br> Let‚Äôs consider the case of Caesar Cipher or Shift Cipher as an example.<br> As the name suggests, in Caesar‚Äôs Cipher each character in a word is replaced by another character under some defined rules.<br> Thus, if A is replaced by D, B by E and so on.<br> Then, each character in the word would be shifted by a position of 3.<br> For example:
        
        Plaintext : Geeksforgeeks<br>
        Ciphertext : Jhhnvirujhhnv </p>
        
      </div>
      </p>
    

      <p><div id = "DES"><u>Data Encryption Standard (DES)</u>
      
        he Data Encryption Standard (DES) is a symmetric-key block cipher published by the National Institute of Standards and Technology (NIST).

DES is an implementation of a Feistel Cipher. It uses 16 round Feistel structure. The block size is 64-bit. Though, key length is 64-bit, DES has an effective key length of 56 bits, since 8 of the 64 bits of the key are not used by the encryption algorithm (function as check bits only). General Structure of DES is depicted in the following illustration ‚àí
<center>
  <img id="DES1" src="des_structure.jpg" alt="Flowers in Chania">
</center>

Since DES is based on the Feistel Cipher, all that is required to specify DES is ‚àí

Round function
Key schedule
Any additional processing ‚àí Initial and final permutation
Initial and Final Permutation
The initial and final permutations are straight Permutation boxes (P-boxes) that are inverses of each other. They have no cryptography significance in DES. The initial and final permutations are shown as follows ‚àí

<center>
  <img src="initial_and_final_permutation.jpg" alt="Nothing">
</center>




        
      </div>
      </p>
      <BR><br>
      1. Introduction
      The symmetric cryptographic systems known as stream ciphers base their operation on the generation of binary sequences that are combined with the message to be encrypted by binary addition (XOR operation). The sequence used in the transmitter must also be generated in the receiver to recover the message by applying the XOR operation to the received ciphertext [1]. The concept of perfect secrecy defined by Shannon [2] establishes as a condition that the binary sequences used to encrypt the message (ciphering sequences) are random, have a length greater than or equal to the message, and are one time use. Although excellent random generators exist, the need to reproduce the sequence in the receiver makes it necessary to use pseudo-random sequences instead of true random ones. Therefore, pseudorandom number generators (PRNGs) constitute the fundamental part of any stream cipher.
      One of the simplest and most widely used methods to generate cryptographic pseudorandom sequences is the linear feedback shift register (LFSR) [3]. This generator stands out for its simplicity and for the good statistical properties of the generated sequences. In addition, the behavior of the LFSR is completely characterized by the polynomial that defines the applied feedback. Thus, if the polynomial is primitive, the generated sequence reaches the maximum length, which is known as the m-sequence. However, these sequences are easily predictable from 2ùêø
       known elements of the sequence generated by an L-stage LFSR. This makes the sequences obtained from an LFSR not directly usable. Instead, non-linear filtering or non-linear combinations of various LFSRs have to be applied to ensure the cryptographic security of stream ciphers, such as those used in mobile and wireless communication systems, e.g., Bluetooth [4], wireless area networks [5], or GSM [6]. On the other hand, although LFSRs are generically defined on a finite field ùê∫ùêπ(ùëû)
      , practical implementations of these ciphers are carried out on ùê∫ùêπ(2)
       to integrate with bitwise operations. Nevertheless, these operations are clearly inefficient when using current processors that work with 16-, 32-, or 64-bit words. For this reason, the extended Galois fields ùê∫ùêπ(2ùëõ)
      , where 2ùëõ
       matches the processor word length, have been analyzed to substitute ùê∫ùêπ(2)
       in cryptographic applications [7,8,9]. In the particular case of LFSR-based stream ciphers, the SNOW 3G algorithm [10] is currently used in 3G and 4G mobile communication systems, and several proposals have recently appeared to be applied to 5G communications [11,12,13]. However, computations on an extended field are time consuming, much more than in the base field [14]. Although the bit generation rate improves n times the binary case, the overall performance of the system does not, sometimes being even lower. In fact, several methods have been developed to reduce computational time, such as precomputed tables, optimized algorithms for multiplication [15], or the use of representations of the ùê∫ùêπ(2ùëõ)
       elements in terms of ùê∫ùêπ(2ùëö)
       elements with ùëö<ùëõ
      . In contrast to binary case, where any primitive polynomial guarantees a sequence of maximum length, only certain primitive polynomials that facilitate its implementation are used in extended fields. This means that they do not require excessive resource consumption, as the SNOW 3G case does, defined to work on devices with 32-bit processors by combining operations with 32-bit and 8-bit arguments. On the other hand, the identification of primitive polynomials in ùê∫ùêπ(2ùëõ)
       requires a much higher computational effort than in the binary case.
      This article presents two methods that reduce the execution time for the implementation of an LFSR and the search for primitive polynomials in the extended filed ùê∫ùêπ(2ùëõ)
      . These methods are based on the model that establishes a direct relationship between the m-sequence generated by an LFSR in ùê∫ùêπ(2ùëõ)
       and the interleaving of n m-sequences generated by n LFSRs in ùê∫ùêπ(2)
      . This relationship was used by Komo and Lam [16] to build primitive polynomials in ùê∫ùêπ(2ùëõ)
       in terms of primitive polynomials in ùê∫ùêπ(2)
      , establishing the relationships that must hold between both polynomials. We propose to use these relationships in the opposite direction; that is, we propose to represent the primitive polynomial over ùê∫ùêπ(2ùëõ)
       in terms of binary LFSRs. In this way, the same sequences will be generated using only binary operations (XOR). However, moving from n-bit word operations to bit operations would be back to square one, since the main reason for using LFSR on extended fields is to take advantage of the capabilities of n-bit processors where bit operations are inefficient. Taking into account that the n binary LFSRs that allow generating the same sequence as the LFSR in ùê∫ùêπ(2ùëõ)
       have all the same primitive feedback polynomial in ùê∫ùêπ(2)
      , the previous obstacle can be easily overcame. Thus, the calculation of the bit operations of the n binary LFSRs can be performed jointly, giving rise to XOR operations between n-bit words and eliminating the inefficiency generated by single-bit operations in this type of processor. The efficiency improvement provided by the proposed implementation turns it into a method especially suitable for cryptanalysis tasks where any execution time reduction in the systems under analysis is very appreciated. Therefore, security assessments performed to cryptosystems based on LFSR in extended fields must take into account the proposed implementation to report a more realistic security level. Additionally, the proposed method allows any primitive polynomial in ùê∫ùêπ(2ùëõ)
       to be used as feedback polynomial of an LFSR, thus overcoming the current limitations.
      The rest of the paper is organized as follows. In Section 2, the mathematical background and notation are introduced, with special emphasis on the LFSR fundamentals and the relationships between the m-sequences generated in extended and base fields, ùê∫ùêπ(ùëûùëõ)
       and ùê∫ùêπ(ùëû)
      . Section 3 describes the proposed implementation for the particular case of LFSRs defined in ùê∫ùêπ(2ùëõ)
       through a different and more efficient way. Section 4 contains the algorithm proposed to test the primitiveness of polynomials making use of the same relationships. Finally, discussion about security and efficiency of the implementations and conclusion are included in Section 5 and Section 6, respectively.
      2. Mathematical Background
      Let ùê∫ùêπ(ùëû)
       be the finite field of q elements, q being a prime, and ùê∫ùêπ[ùëû,ùë•]
       the set of all polynomials with coefficients in ùê∫ùêπ(ùëû)
      . Equivalently, let ùê∫ùêπ(ùëûùëõ)
       be the finite field of ùëûùëõ
       elements, and ùê∫ùêπ[ùëûùëõ,ùë•]
       the set of all polynomials with coefficients from ùê∫ùêπ(ùëûùëõ)
      . A generator of the cyclic group of a finite field is called a primitive element of that field. Hence, a polynomial ùëù(ùë•)‚ààùê∫ùêπ[ùëû,ùë•]
       of degree ùëö‚â•1
       is called primitive over ùê∫ùêπ(ùëû)
       if it is the minimal polynomial over ùê∫ùêπ(ùëû)
       of a primitive element ùõº‚ààùê∫ùêπ(ùëûùëõ)
      . A primitive polynomial ‚Ñé(ùë•)
       of degree n allows one to construct ùê∫ùêπ(ùëûùëõ)
       in such a way that:
      ùê∫ùêπ(ùëûùëõ)‚âàùê∫ùêπ[ùëû,ùë•]/‚Ñé(ùë•)
      (1)
      The addition and multiplication in ùê∫ùêπ(ùëûùëõ)
       are the ones in ùê∫ùêπ[ùëû,ùë•]
      , but performing the module ‚Ñé(ùë•)
       reduction, as all the elements in ùê∫ùêπ(ùëûùëõ)
       can be represented as polynomials of degree less than n with coefficients in ùê∫ùêπ(ùëû)
      . On the other hand, any element ùëé‚ààùê∫ùêπ(ùëûùëõ)
       can be expressed in terms of a basis {ùõºùëõ‚àí1,‚ãØ,ùõº2,ùõº,1}
      , ùõº
       being a root of ‚Ñé(ùë•)
       in ùê∫ùêπ(ùëûùëõ)
      . Consequently, any element ùëé‚ààùê∫ùêπ(ùëûùëõ)
       can be written as the vector (ùëéùëõ‚àí1,‚ãØ,ùëé1,ùëé0)
       where:
      ùëé=ùëéùëõ‚àí1ùõºùëõ‚àí1+‚ãØ+ùëé1ùõº+ùëé01.
      (2)
      For ùëû=2
      , it is very common to use the hexadecimal notation as a compact representation of the elements in ùê∫ùêπ(ùëûùëõ)
      . Thus, if we use ‚Ñé(ùë•)=ùë•8+ùë•4+ùë•3+ùë•2+1
       to construct ùê∫ùêπ(28)
      , ùõº
       being a root of ‚Ñé(ùë•)
      , as any element in ùê∫ùêπ(28)
       can be represented as a power of ùõº
      , we can write the element ùõº3
       as (0,0,0,0,1,0,0,0)
       or 0ùë•08
       and the element ùõº10=ùõº6+ùõº5+ùõº4+ùõº2
       as (0,1,1,1,0,1,0,0)
       or 0ùë•74
      . Note that the powers of ùõº
       correspond to the vector components in descending order, beginning from the left, to facilitate the conversion to and from hexadecimal values.
      2.1. Linear Feedback Shift Registers
      An LFSR defined over ùê∫ùêπ(ùëû)
       is a collection of L memory cells ùëèùëñ
      , 0‚â§ùëñ‚â§ùêø‚àí1
      , whose contents belong to that field and are updated synchronously by a master clock, by the following equations:
      ùõæ=ùëèùêø‚àí1ùëê1+ùëèùêø‚àí2ùëê2+‚ãØ+ùëè1ùëêùêø‚àí1+ùëè0ùëêùêø,ùëèùëñ=ùëèùëñ+1,0‚â§ùëñ‚â§ùêø‚àí2,ùëèùêø‚àí1=ùõæ,
      (3)giving rise to the sequence ùê∑=ùëë0ùëë1ùëë2‚ãØ
      , which is completely determined by the initial state of the cells, named seed, and the feedback coefficients ùëêùëñ‚ààùê∫ùêπ(ùëû)
      , 1‚â§ùëñ‚â§ùêø
       according to the linear recurrence:
      ùëëùëñ=ùëëùëñ‚àí1ùëê1+ùëëùëñ‚àí2ùëê2+‚ãØ+ùëë1ùëêùêø‚àí1+ùëë0ùëêùêø,
      (4)where ùëë0,ùëë1,‚ãØ,ùëëùêø‚àí1
       correspond to the seed (see Figure 1). The length of the sequence D can be analyzed in terms of the connection polynomial ùëù(ùë•)
       composed with the feedback coefficients:
      ùëù(ùë•)=ùëê0+ùëê1ùë•+ùëê2ùë•2+‚ãØ+ùëêùêø‚àí1ùë•ùêø‚àí1+ùëêùêøùë•ùêø,
      (5)in such a way that the maximal sequence length ùëûùêø‚àí1
       is achieved when ùëù(ùë•)
       is primitive. In such a case, the sequence is called m-sequence and is independent from the chosen seed.
      Mathematics 10 00996 g001 550Figure 1. Linear feedback shift register.
      Stream ciphers are mainly based on LFSRs defined over finite fields with ùëû=2
       [1]. Hence, the cell content is one bit, and the addition and multiplication correspond to XOR and AND operations, respectively. However, for efficiency reasons, in the generation process, LFSRs defined in ùê∫ùêπ(2ùëõ)
       are also being used in current communication systems. When LFSR is defined in this extension field, the cells contain n-bit words, where n matches the processor‚Äôs word length. Although the equations that govern the LFSR are the same, as described above, addition and multiplication are defined as polynomial addition and multiplication modulus ‚Ñé(ùë•)
      , the polynomial used to construct the ùê∫ùêπ(2ùëõ)
      . From now on, we shall use the notation <ùêø,ùëù(ùë•)>
       to refer to an LFSR with L cells in ùê∫ùêπ(2)
       and connection polynomial ùëù(ùë•)‚ààùê∫ùêπ[2,ùë•]
       of degree L. The form <ùêø,ùëù(ùë•),ùëõ>
       is for an LFSR of L cells in ùê∫ùêπ(2ùëõ)
       and connection polynomial ùëù(ùë•)‚ààùê∫ùêπ[2ùëõ,ùë•]
       of degree L.
      2.2. Binary Equivalent Model
      Komo and Lam [16] proposed a method to generate primitive polynomials in ùê∫ùêπ(ùëûùëõ)
       using primitive polynomials in ùê∫ùêπ(ùëû)
       based on the relationship previously discovered by Park and Komo [17] between the m-sequences produced in ùê∫ùêπ(ùëûùëõ)
       and ùê∫ùêπ(ùëû)
      , in such a way that an m-sequence in ùê∫ùêπ(ùëûùëö)
       can be decomposed into n m-sequences in ùê∫ùêπ(ùëû)
      . More precisely:
      Theorem 1 (cf. [17], th 7). Let ùëù(ùë•)
       be a primitive polynomial of degree ùëö¬∑ùëõ
       in ùê∫ùêπ[ùëû,ùë•]
      . Let ùëì(ùë•)
       be one of the n primitive polynomials of degree m in ùê∫ùêπ[ùëûùëõ,ùë•]
       into which ùëù(ùë•)
       factors when viewed in ùê∫ùêπ[ùëûùëõ,ùë•]
      . Let ùê∑=ùëë0,ùëë1,‚ãØ
       be an m-sequence over ùê∫ùêπ(ùëûùëõ)
       generated by ùëì(ùë•)
      . If
      ùëëùëñ=ùëëùëñ,0ùúÜ0+ùëëùëñ,1ùúÜ1+‚ãØ+ùëëùëñ,ùëõ‚àí1ùúÜùëõ‚àí1
      (6)where {ùúÜ0,ùúÜ1,‚ãØ,ùúÜùëõ‚àí1}
       is a basis for ùê∫ùêπ(ùëûùëõ)
       over ùê∫ùêπ(ùëû)
      , then the sequence ùëë0,ùëó,ùëë1,ùëó,‚ãØ
       is an m-sequence of length ùëûùëõùëö‚àí1
       over ùê∫ùêπ(ùëû)
      .
      As one can observe, the sequence ùëë0,ùëó,ùëë1,ùëó,‚ãØ
       is composed by the j-th component of each element ùëëùëñ
       in the sequence D. Equivalently, the sequence ùëë0,ùëó,ùëë1,ùëó,‚ãØ
       can be considered as a decimation sequence obtained from D giving rise to the following set of decimated sequences, as it is shown in Figure 2:
      ùê∑ùëó=ùëë0,ùëó,ùëë1,ùëó,ùëë2,ùëó,‚ãØ,
      (7)
      Mathematics 10 00996 g002 550Figure 2. Relationship between m-sequences in the extended and base fields.
      Furthermore, as it is stated in [16], since the sequences ùê∑ùëó
      , for 0‚â§ùëó‚â§ùëõ‚àí1
      , are generated by the same polynomial ùëì(ùë•)
      , all of them are shifted versions of the same m-sequence. Hence, taking ùê∑0
       as the reference, we can define ùúÉùëó
       as the shift of ùê∑ùëó
       respect to ùê∑0
      . In [16], a method to obtain a primitive polynomial ùëì(ùë•)‚ààùê∫ùêπ[ùëûùëõ,ùë•]
       in terms of a given primitive polynomial ùëù(ùë•)‚ààùê∫ùêπ[ùëû,ùë•]
       is proposed by means of the computation of the shifts ùúÉùëó
       that satisfy the relationship between the m-sequences in the extended and base fields.
      3. Efficient LFSR Implementation
      The relationship between the m-sequences on ùê∫ùêπ(2ùëõ)
       and the m-sequences on ùê∫ùêπ(2)
      , as described in the previous section, also allows us to establish an equivalence between the LFSRs that generate them. This section presents a practical and efficient method to obtain such LFSRs, i.e., to obtain the feedback polynomial ùëù(ùë•)
       and the seeds of each LFSR <ùêøùëõ,ùëù(ùë•)>
       that allow us to generate the same sequence as the LFSR <ùêø,ùëì(ùë•),ùëõ>
       from a given seed. Note that, according to the equivalent model, the n LFSRs in ùê∫ùêπ(2)
       have the same connection polynomial ùëù(ùë•)
       but different seeds, all of them related to the seed in ùê∫ùêπ(2ùëõ)
      . Hence, in order to efficiently implement the LFSR <ùêø,ùëì(ùë•),ùëõ>
       using the equivalent model, it is necessary to solve three main questions: the computation of ùëù(ùë•)
      , the computation of the seeds, and how to speed up the performance of the binary LFSRs.
      Since the connection polynomial ùëì(ùë•)
       is primitive, the minimal polynomial ùëù(ùë•)
       of the decimated sequences ùê∑ùëñ
       is also primitive and unique for 0‚â§ùëñ‚â§ùëõ‚àí1
      . Hence, ùëù(ùë•)
       can be obtained analyzing a decimated sequence using the Massey‚ÄìBerlekamp algorithm [18]. Consequently, the following Algorithm 1 is defined.
      Algorithm 1: Computation of connection polynomial ùëù(ùë•)
      .
      ‚ÄÉinput  : LFSR <ùêø,ùëì(ùë•),ùëõ>
      
      ‚ÄÉoutput: ùëù(ùë•)
       in LFSR <ùêøùëõ,ùëù(ùë•)>
      Implement the LFSR<ùêø,ùëì(ùë•),ùëõ>
      ;
      Generate2ùêøùëõ+1
      elements, at least, using any nonzero seed;
      Obtain a decimated sequenceùê∑ùëñ
      for anyùëñ,0‚â§ùëñ‚â§ùëõ‚àí1
      ;
      Obtain the minimal polynomialùëù(ùë•)
      of theùê∑ùëñ
      generated in step 3
      Once ùëù(ùë•)
       has been determined, we can construct the n LFSRs <ùêøùëõ,ùëù(ùë•)>
      , but we need their respective seeds in order to generate the same sequence as that generated from the initial seed ùë†=(ùëë0,ùëë1,‚ãØ,ùëëùêø‚àí1)
       in the extended field. As it is derived from the equivalent model, the L known elements in ùê∫ùêπ(2ùëõ)
       that compose the initial seed only provide us with ùëõùêø
       bits, while ùëõ2ùêø
       bits are needed to complete the n seeds in ùê∫ùêπ(2)
       (see Figure 3). Thus, the seed ùë†ùëó
       of ùê∑ùëó
       can be partially written in terms of the seed s of D as:
      ùë†ùëó=ùëë0,ùëó,ùëë1,ùëó,‚ãØ,ùëëùêø‚àí1,ùëó,ùëëùêø,ùëó,‚ãØ,ùëëùëõ¬∑ùêø‚àí1,ùëó
      (8)where ùëëùêø,ùëó,‚ãØ,ùëëùëõ¬∑ùêø‚àí1,ùëó
       are unknown for 0‚â§ùëó‚â§ùëõ‚àí1
      . However, the shifts ùúÉùëñ
       that relate the binary sequences to each other allow us to obtain the seeds completely. The following subsections describes the computation of ùúÉùëó
       and ùë†ùëó
      .
      Mathematics 10 00996 g003 550Figure 3. LFSR seeds in the binary equivalent model.
      3.1. Computation of Shifts
      All decimated sequences ùê∑ùëó
       have the same primitive minimal polynomial ùëù(ùë•)
      , obtained using Algorithm 1. Hence, all of them are shifted versions of the others. The shift ùúÉùëó
       of ùê∑ùëó
       with respect to ùê∑0
       allows one to obtain the state of the j-th LFSR (the one that generates ùê∑ùëó
      ) from the state of the 0-th LFSR as follows:
      (ùëë0,ùëó,ùëë1,ùëó,‚ãØ,ùëëùëõ¬∑ùêø‚àí1,ùëó)=(ùëë0,0,ùëë1,0,‚ãØ,ùëëùëõ¬∑ùêø‚àí1,0)ùê¥ùúÉùëó,
      (9)where A is the connection matrix of ùëù(ùë•)
      , that is:
      ùê¥=‚é°‚é£‚é¢‚é¢‚é¢‚é¢‚é¢‚é¢010‚ãÆ0001‚ãÆ0‚ãØ‚ãØ‚ãØ‚ã±‚ãØ000‚ãÆ1ùëêùëõ¬∑ùêøùëêùëõ¬∑ùêø‚àí1ùëêùëõ¬∑ùêø‚àí2‚ãÆùëê1‚é§‚é¶‚é•‚é•‚é•‚é•‚é•‚é•
      (10)
      The computation of ùúÉùëó
       is not an easy task. Furthermore, the computation of ùê¥ùúÉùëó
       is time-consuming. Instead, we can obtain the matrix ùê¥(ùëó)=ùê¥ùúÉùëó
       solving the linear equation system of Equation (9). Note that we have n matrices ùê¥(ùëó)
       to compute and thus n linear systems to solve. The linear system in Equation (9), stated using the first ùëõùêø
       element, the seed, has ùëõùêø
       equations and ùëõ2ùêø2
       unknowns. Each new element of the sequence defines ùëõùêø
       new equations with the same unknowns. Hence, the 2ùêøùëõ+1
       elements of the m-sequence in ùê∫ùêπ(2ùëõ)
       generated in Algorithm 1 to obtain ùëù(ùë•)
       provide enough equations to solve the systems. As an example, we consider a 3-stage LFSR defined in ùê∫ùêπ(24)
      , that is, the LFSR <3,ùëì(ùë•),4>
      , where ùëì(ùë•)=1+ùë•+(0ùë•9)ùë•3
       is primitive over ùê∫ùêπ(24)
       and the primitive polynomial ùë•4+ùë•+1
       has been used to construct ùê∫ùêπ(24)
      . From the initial seed (1,1,1,1),(0,0,0,0),(0,1,1,0)
       or, equivalently, (1+ùõº+ùõº2+ùõº3,0,ùõº+ùõº2)
      , ùõº
       being a root of ùë•4+ùë•+1
      , the LFSR <3,ùëì(ùë•),4>
       generates the following sequence:
      001000001100111010010000‚ãØ101001011000000001010001‚ãØ101110100000001111001000‚ãØ001110000001000101100011‚ãØ
      (11)where the elements of ùê∫ùêπ(24)
       are represented in columns with the least significant bit at the top. The four decimated sequences are all generated by the same primitive polynomial ùëù(ùë•)=ùë•12+ùë•6+ùë•5+ùë•3+1
       and, hence, all of them are shifted versions of the same m-sequence. Solving the system in Equation (9), we obtain the matrices ùê¥(1),ùê¥(2),ùê¥(3)
      :
      ùê¥(1)=‚é°‚é£‚é¢‚é¢‚é¢‚é¢‚é¢‚é¢‚é¢‚é¢‚é¢‚é¢‚é¢‚é¢‚é¢‚é¢‚é¢‚é¢‚é¢‚é¢‚é¢‚é¢100000000110010000000011101000000001110100000000011010000000001101000000000110100110000011010101000001101010000000110011000000011001000000001100‚é§‚é¶‚é•‚é•‚é•‚é•‚é•‚é•‚é•‚é•‚é•‚é•‚é•‚é•‚é•‚é•‚é•‚é•‚é•‚é•‚é•‚é•ùê¥(2)=‚é°‚é£‚é¢‚é¢‚é¢‚é¢‚é¢‚é¢‚é¢‚é¢‚é¢‚é¢‚é¢‚é¢‚é¢‚é¢‚é¢‚é¢‚é¢‚é¢‚é¢‚é¢000000101010000000010101100000001010110000000101111000000010011100000001101110101010010111111111001011111111000101010101000010101010000001010101‚é§‚é¶‚é•‚é•‚é•‚é•‚é•‚é•‚é•‚é•‚é•‚é•‚é•‚é•‚é•‚é•‚é•‚é•‚é•‚é•‚é•‚é•ùê¥(3)=‚é°‚é£‚é¢‚é¢‚é¢‚é¢‚é¢‚é¢‚é¢‚é¢‚é¢‚é¢‚é¢‚é¢‚é¢‚é¢‚é¢‚é¢‚é¢‚é¢‚é¢‚é¢000111111111000011111111000001111111000000111111100000011111010000001111001111111000100000000011110000000001111111111111011111111111001111111111‚é§‚é¶‚é•‚é•‚é•‚é•‚é•‚é•‚é•‚é•‚é•‚é•‚é•‚é•‚é•‚é•‚é•‚é•‚é•‚é•‚é•‚é•
      (12)
      Since the decimated sequences have a small period of 212‚àí1=4095
      , we have also compared them to obtain the shifts ùúÉ1=3276
      , ùúÉ2=3549
      , and ùúÉ3=3822
      . In a real scenario, ùúÉùëó
       is not going to be computed. It is important to point out that the calculation of the ùê¥(ùëó)
       matrices can be performed prior to the normal operation of the LFSR since they do not depend on the seeds.
      3.2. Computation of Seeds
      Let us consider that the shift matrices ùê¥(ùëó)=ùê¥ùúÉùëó
       have already been precomputed. For any given seed (ùëë0,ùëë1,‚ãØ,ùëëùêø‚àí1)
      , the seeds of the binary LFSRs can be represented as:
      (ùëë0,ùëó,ùëë1,ùëó,‚ãØ,ùëëùëõ¬∑ùêø‚àí1,ùëó)=(ùëë0,0,ùëë1,0,‚ãØ,ùëëùëõ¬∑ùêø‚àí1,0)ùê¥(ùëó),
      (13)where ùëëùêø,ùëó,‚ãØ,ùëëùëõ¬∑ùêø‚àí1,ùëó
       are unknowns for every 0‚â§ùëó‚â§ùëõ‚àí1
      . The values ùëëùêø,0,
      ‚ãØ,
      ùëëùëõ¬∑ùêø‚àí1,0
       can be obtained solving the linear system composed with the (ùëõ¬∑ùêø‚àíùêø)
       equations with the known values ùëë0,ùëó,ùëë1,ùëó,‚ãØ,ùëëùêø‚àí1,ùëó,
       for 0‚â§ùëó‚â§ùëõ‚àí1
      , i.e.:
      ùëëùëñ,ùëó=‚àëùëò=0ùëõ¬∑ùêø‚àí1ùëëùëò,0ùëé(ùëó)ùëò,ùëñ,0‚â§ùëñ‚â§ùêø‚àí1,1‚â§ùëó‚â§ùëõ‚àí1,
      (14)where ùëé(ùëó)ùëò,ùëñ
       are the components of the matrix ùê¥(ùëó)
      . The remaining seeds (ùëë0,ùëó,ùëë1,ùëó,
      ‚ãØ,ùëëùëõ¬∑ùêø‚àí1,ùëó)
      , with 1‚â§ùëó‚â§ùêø‚àí1
      , are calculated using Equation (13). Considering the precomputed matrices in Equation (12) of the previous example, the Equation (13) can be written as:
      (1,0,1,ùëë3,1,‚ãØ,ùëë11,1)=(0,0,1,ùëë3,0,‚ãØ,ùëë11,0)ùê¥(1)(1,0,1,ùëë3,2,‚ãØ,ùëë11,2)=(0,0,1,ùëë3,0,‚ãØ,ùëë11,0)ùê¥(2)(0,0,1,ùëë3,3,‚ãØ,ùëë11,3)=(0,0,1,ùëë3,0,‚ãØ,ùëë11,0)ùê¥(3)
      (15)
      Solving for (ùëë3,0,‚ãØ,ùëë11,0)
      , we obtained the complete seed for the sequence ùê∑0
      , that is, (0,0,1,0,0,0,0,0,1,1,0)
      . Next, using the matrices ùê¥(1)
      , ùê¥(2)
       and ùê¥(3)
      , the complete seeds of the sequences ùê∑1
      , ùê∑2
      , and ùê∑3
       are obtained. Hence, we have:
      ùë†ùëíùëíùëë0=(0,0,1,0,0,0,0,0,1,1,0)ùë†ùëíùëíùëë1=(1,0,1,0,0,1,0,1,1,0,0)ùë†ùëíùëíùëë2=(1,0,1,1,1,0,1,0,0,0,0)ùë†ùëíùëíùëë3=(0,0,1,1,1,0,0,0,0,0,0)
      (16)
      3.3. Grouped Operations
      Once the n binary LFSRs have been constructed, it is time to generate the sequence. Instead of running n independent instances of the binary LFSR, which require 1-bit operations with an n-bit processor, we propose to group the n LFSRs into a unique LFSR with connection polynomial ùëù(ùë•)
       but using n-bit cells. The result is not an LFSR over ùê∫ùêπ(2ùëõ)
       but a parallel implementation of n LFSR over ùê∫ùêπ(2)
       using only one processor. Since the addition and multiplication in the binary LFSRs correspond to the XOR and AND bitwise operations, respectively, instead of applying the XOR to 1-bit values, we apply it over n-bit values. The processor takes the same time to perform the XOR operation with 1-bit values than with n-bit values because the word length is n, thus saving a lot of execution time. Hence, Equation (4) can be redefined as follows:
      ‚é°‚é£‚é¢‚é¢‚é¢ùëëùëñ,0‚ãÆùëëùëñ,ùëõ‚àí1‚é§‚é¶‚é•‚é•‚é•=ùëê1‚é°‚é£‚é¢‚é¢‚é¢ùëëùëñ‚àí1,0‚ãÆùëëùëñ‚àí1,ùëõ‚àí1‚é§‚é¶‚é•‚é•‚é•+ùëê2‚é°‚é£‚é¢‚é¢‚é¢ùëëùëñ‚àí2,0‚ãÆùëëùëñ‚àí2,ùëõ‚àí1‚é§‚é¶‚é•‚é•‚é•+‚ãØ+ùëêùêø‚é°‚é£‚é¢‚é¢‚é¢ùëëùëñ‚àíùêøùëõ,0‚ãÆùëëùëñ‚àíùêøùëõ,ùëõ‚àí1‚é§‚é¶‚é•‚é•‚é•,
      (17)in such a way that the n sequences stated in Equation (7) are simultaneously generated using a unique polynomial ùëù(ùë•)
       (see Equation (5)).
      From the practical implementation perspective, there is no difference at all with respect to preforming a classical binary LFSR, which includes coding and execution, since the 1-bit XOR operation is actually performed taking n-bit operands. Hence, the n-bit grouped operation proposed in this paper is a way of not wasting the capacity of the operations of the n-bit processors. As a consequence, this implementation method increases the bit generation net rate by n because the generation of a new element of a 32-bit m-sequence takes the same amount of time as a new element of a 1-bit m-sequence.
      4. Primitiveness Test
      As mentioned in Section 2.2, the m-sequences generated by an LFSR in ùê∫ùêπ(2ùëõ)
       can be decomposed into n m-sequences generated by n LFSRs in ùê∫ùêπ(2)
      , so that when the feedback polynomial of the LFSR in the extended field is primitive, all LFSRs in ùê∫ùêπ(2)
       have the same feedback polynomial, and it is also primitive. This relationship is what allows us to propose an algorithm to check if a polynomial is primitive over ùê∫ùêπ(2ùëõ)
      .
      In general terms, to check if a polynomial ùëì(ùë•)
       over ùê∫ùêπ(2ùëõ)
       is primitive, we propose to build an LFSR whose feedback polynomial is ùëì(ùë•)
       and generate 2¬∑ùëö¬∑ùëõ+1
       elements, at least. The sequence generated by concatenating all generated elements is decomposed into n binary sequences by decimating by n, as it is stated in Equation (7). Next, the n sequences are processed to obtain the minimal polynomials of the binary LFSRs that generate them (This can be achieved using the Berlekamp‚ÄìMassey algorithm). If all the n sequences are generated by the same polynomial and it is also primitive, then ùëì(ùë•)
       is primitive over ùê∫ùêπ(2ùëõ)
      . Algorithm 1 can be extended including one more step (step 5) to perform the check, resulting in Algorithm 2.
      Algorithm 2: Primitiveness test.
      Mathematics 10 00996 i001
      As an example, let us consider the degree 6 polynomial ùëì(ùë•)=0ùë•1+0ùë•2¬∑ùë•+0ùë•4¬∑ùë•2+0ùë•8¬∑ùë•3+0ùë•5¬∑ùë•4+0ùë•9¬∑ùë•5+ùë•6‚ààùê∫ùêπ[24,ùë•]
      , where the primitive polynomial ‚Ñé(ùë•)=ùë•4+ùë•+1
       has been used to construct ùê∫ùêπ(24)
      . In order to check if ùëì(ùë•)
       is primitive, we consider ùëì(ùë•)
       as the feedback polynomial of an LFSR in the ùê∫ùêπ(24)
       of 6 cells. For a random seed (0ùë•9,0ùë•4,0ùë•5,0ùë•9,0ùë•5,0ùë•1)
      , we generate 2ùëöùëõ+1=49
       elements, giving rise to the following decimated sequences:
      ùê∑0=0010011011100000011010110001000000101011001111100ùê∑1=0101100111010011110000001010111101111001011010001ùê∑2=0000000011000101110101100100010010011000001000101ùê∑3=1111011111000011001111010101101110100100010100001
      (18)
      The same minimal polynomial ùëù(ùë•)
       is obtained for each ùê∑ùëñ
       sequence by means of the Massey‚ÄìBerlekamp algorithm [18]. The polynomial is the following:
      ùëù(ùë•)=ùë•24+ùë•23+ùë•22+ùë•21+ùë•20+ùë•19+ùë•15+ùë•14+ùë•9+ùë•8+ùë•7+ùë•6+1
      (19)
      Since ùëù(ùë•)
       is primitive over ùê∫ùêπ(2)
      , we can conclude that ùëì(ùë•)
       is primitive over ùê∫ùêπ(24)
      .
      5. Efficiency and Security
      The implementation presented in Section 3 considerably reduces the execution time of the LFSRs defined in ùê∫ùêπ(2ùëõ)
      . Specifically, an implementation of the LFSR used in the SNOW 3G stream cipher has been performed and compared with the implementation provided in the technical specification of the protocol [10]. This is an LFSR <16,ùëì(ùë•),32>
      . Hence, the equivalent model is based on 32 LFSRs <512,ùëù(ùë•)>
      . The polynomial ùëù(ùë•)
       is built from 1024 elements generated using the official implementation [10] following the steps established in Algorithm 1. The result is that the 32 decimated sequences have the same minimal polynomial ùëù(ùë•)
       of degree 512, whose coefficients are represented below in compact hexadecimal format:
      84009ùê∂624ùê∑4ùêπ75ùêπ17ùê∏ùê∑ùê¥41ùê∂663ùê∂5ùê∑ùêπùê∑ùê∏ùê∑8ùê¥535ùê∑ùê¥1ùê∂5ùêπ70824152ùê¥7
      (20)
      ùê∂23ùê∏ùê∑ùêµ90ùê∑572852ùê¥765ùêπùêπ5ùêπ2012ùê¥64ùêπ5ùê∑3ùêπùê∑361ùêµ005ùê¥ùê∑ùêµùê¥45ùê¥1995
      (21)
      ‚ÄÉ‚ÄÉ‚ÄÉ‚ÄÉ‚ÄÉ‚ÄÉ‚ÄÉ‚ÄÉ‚ÄÉ‚ÄÉ‚ÄÉ‚ÄÉ‚ÄÉ‚ÄÉ‚ÄÉ‚ÄÉ‚ÄÉ‚ÄÉùê∏64ùê∏48362706ùê∑62606828
      (22)
      Despite the fact that ùëù(ùë•)
       has 250 non-zero coefficients, and therefore 250 XOR operations are required to generate the next element in the sequence, the execution time is 3.3 times lower than the original implementation. The computation of the matrices ùê¥(ùëó)
       is not considered, since this is performed prior to the normal operating of the LFSR. The times have been calculated by taking the average of 10 repetitions of each generation of 1000, 10,000, 20,000, 50,000, and 100,000 elements. Both implementations have been made in Python 3.9 language and have been executed on an Intel(R) Core(TM) i7-10510U 64-bit processor with 16 GB of RAM. Although the SNOW 3G algorithm has been designed to be executed on 32-bit platforms, the tests carried out on a 64-bit processor are completely valid since the greater word length of the processor compared to the algorithm does not affect the normal execution of our implementation. Note that the goal is to achieve an implementation of an algorithm defined in ùê∫ùêπ(2ùëõ)
       using n-bit operations. The case of working with processors of more than n bits offers the possibility of developing new faster implementations to make the most of their capacity, but requires adapting the algorithms to the new processor architecture. This is outside the scope of this work.
      As mentioned in the Section 3, the net bit generation rate is increased by n when compared to a single binary LFSR implementation, that is, to a binary LFSR using the same connection polynomial. However, the improvement observed in the tests on SNOW 3G does not reach the net rate. This is mainly due to the number of non-zero coefficients in ùëù(ùë•)
       that slow down the computation. Therefore, in the case of equivalent binary polynomials ùëù(ùë•)
       with a few nonzero coefficients, the real rate will reach the net rate. In the general case, the fewer non-zero coefficients in ùëù(ùë•)
      , the greater the improvement to the generation rate.
      The efficiency of the proposed implementations, shown in Section 3 affects the security of the cryptosystems used by these LFSRs, although, in general, they are not intended to replace those currently used by most devices, such as smartphones, but rather for use in mobile devices without any type of restriction, such as personal computers or servers. Using the equivalent model implies multiplying by n, the number of bits needed to generate a new element of the m-sequence over ùê∫ùêπ(2ùëõ)
      , that is, to generate n bits. In the case of SNOW 3G, it goes from 512 to 16,384 bits. Therefore, the theoretical improvement of the execution time by a factor n is associated with an increase in the same factor n in the amount of memory needed to generate the same number of bits. As a consequence, this implementation provides a substantial improvement for the calculation of m-sequences that, although it could not be deployed on some devices, could always be used for cryptanalysis tasks. Regarding the cost of our proposal, an increment in the memory cells must be taken in mind, rising from ùëõùêø
       to ùëõ2ùêø
       bits.
      Regarding the algorithm for primitiveness testing, we can conclude that it has a better performance than O‚ÄôConnor‚Äôs algorithm, one of the most used ones. The main advantage is that the proposed algorithm has to generate 2ùëöùëõ+1
       elements instead of the whole sequence or alternatively to perform as many divisions as elements in the maximal sequence over the extended field. The validation and comparison tests have been performed using Mathematica software, version 10.0.0
      , on a 64-bits Microsoft Windows platform running on a Intel(R) Core (TM) processor with i7-4510U CPU @ 2.00
       GHz and 16 GB RAM. The processor‚Äôs temperature and the amount of simultaneous running processes have been taken into account for the execution time comparison. Figure 4 shows the behavior of the algorithm with respect to O‚ÄôConnor‚Äôs in ùê∫ùêπ(28)
       and ùê∫ùêπ(216)
      , respectively.
      Mathematics 10 00996 g004 550Figure 4. Execution time in ùê∫ùêπ(28)
       and ùê∫ùêπ(216)
      .
      6. Conclusions
      In this article, we have presented two real applications of the relationships between the m-sequences in ùê∫ùêπ(2ùëõ)
       and ùê∫ùêπ(2)
      . The first one is a new algorithm designed to verify the primitiveness of polynomials with coefficients in ùê∫ùêπ(2ùëõ)
       that improves the execution times of existing methods. The second one is the support of an efficient implementation of the LFSRs defined over the extended field ùê∫ùêπ(2ùëõ)
      , which improves the other implementations. It enables better performance of the LFSR-based stream ciphers, often used in high speed communication systems. The improvement is achieved by a combination of the binary equivalent model of LFSRs in the extended field, which uses only binary operations, and the n-bit grouped operation that take advantage of the n-bit processors. The feasibility of the implementation has been shown by applying it to the SNOW 3G stream cipher, whose execution time has been reduced by a factor of 3.3 with respect to the code provided in the technical specification of the protocol. These results can also be extended to cryptanalysis, making use of not only the grouped operations but of the underlying binary structure that may facilitate the parallelization of the operations. On the other hand, the proposed implementation is software-oriented, although the binary operations also allow hardware implementations. In this way, we provide a complete method to efficiently increase the bit generation rate.

</div>

<a href="C:\My Folder\5th Semester\CRYPTOGRAPHY\New folder\trial.rar" download>link_text</a>


</body>
</html>


